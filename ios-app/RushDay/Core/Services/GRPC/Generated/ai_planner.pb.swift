// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ai_planner.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Rushday_V1_AIEventType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case birthday // = 1
  case wedding // = 2
  case business // = 3
  case babyShower // = 4
  case graduation // = 5
  case engagement // = 6
  case anniversary // = 7
  case other // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .birthday
    case 2: self = .wedding
    case 3: self = .business
    case 4: self = .babyShower
    case 5: self = .graduation
    case 6: self = .engagement
    case 7: self = .anniversary
    case 8: self = .other
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .birthday: return 1
    case .wedding: return 2
    case .business: return 3
    case .babyShower: return 4
    case .graduation: return 5
    case .engagement: return 6
    case .anniversary: return 7
    case .other: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Rushday_V1_AIEventType] = [
    .unspecified,
    .birthday,
    .wedding,
    .business,
    .babyShower,
    .graduation,
    .engagement,
    .anniversary,
    .other,
  ]

}

public enum Rushday_V1_GuestCountRange: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0

  /// 1-10
  case intimate // = 1

  /// 10-25
  case small // = 2

  /// 25-50
  case medium // = 3

  /// 50-100
  case large // = 4

  /// 100+
  case massive // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .intimate
    case 2: self = .small
    case 3: self = .medium
    case 4: self = .large
    case 5: self = .massive
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .intimate: return 1
    case .small: return 2
    case .medium: return 3
    case .large: return 4
    case .massive: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Rushday_V1_GuestCountRange] = [
    .unspecified,
    .intimate,
    .small,
    .medium,
    .large,
    .massive,
  ]

}

public enum Rushday_V1_VenueType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case indoorVenue // = 1
  case outdoorSpace // = 2
  case atHome // = 3
  case hotel // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .indoorVenue
    case 2: self = .outdoorSpace
    case 3: self = .atHome
    case 4: self = .hotel
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .indoorVenue: return 1
    case .outdoorSpace: return 2
    case .atHome: return 3
    case .hotel: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Rushday_V1_VenueType] = [
    .unspecified,
    .indoorVenue,
    .outdoorSpace,
    .atHome,
    .hotel,
  ]

}

public enum Rushday_V1_BudgetTier: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0

  /// up to $1,500
  case economy // = 1

  /// $1,500 - $4,500
  case standard // = 2

  /// $4,500 - $7,500
  case premium // = 3

  /// from $7,500
  case luxury // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .economy
    case 2: self = .standard
    case 3: self = .premium
    case 4: self = .luxury
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .economy: return 1
    case .standard: return 2
    case .premium: return 3
    case .luxury: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Rushday_V1_BudgetTier] = [
    .unspecified,
    .economy,
    .standard,
    .premium,
    .luxury,
  ]

}

public enum Rushday_V1_ServiceType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case catering // = 1
  case decoration // = 2
  case entertainment // = 3
  case photoVideo // = 4
  case invitations // = 5
  case transport // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .catering
    case 2: self = .decoration
    case 3: self = .entertainment
    case 4: self = .photoVideo
    case 5: self = .invitations
    case 6: self = .transport
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .catering: return 1
    case .decoration: return 2
    case .entertainment: return 3
    case .photoVideo: return 4
    case .invitations: return 5
    case .transport: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Rushday_V1_ServiceType] = [
    .unspecified,
    .catering,
    .decoration,
    .entertainment,
    .photoVideo,
    .invitations,
    .transport,
  ]

}

public enum Rushday_V1_PlanTier: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case aiRecommended // = 1
  case popular // = 2
  case standard // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .aiRecommended
    case 2: self = .popular
    case 3: self = .standard
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .aiRecommended: return 1
    case .popular: return 2
    case .standard: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Rushday_V1_PlanTier] = [
    .unspecified,
    .aiRecommended,
    .popular,
    .standard,
  ]

}

public enum Rushday_V1_PlanStyle: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case classic // = 1
  case modern // = 2
  case natural // = 3
  case luxury // = 4
  case custom // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .classic
    case 2: self = .modern
    case 3: self = .natural
    case 4: self = .luxury
    case 5: self = .custom
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .classic: return 1
    case .modern: return 2
    case .natural: return 3
    case .luxury: return 4
    case .custom: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Rushday_V1_PlanStyle] = [
    .unspecified,
    .classic,
    .modern,
    .natural,
    .luxury,
    .custom,
  ]

}

/// Target plan style for single-plan generation requests (parallel mode)
/// Used to generate exactly 1 plan matching a specific budget tier/style
public enum Rushday_V1_TargetPlanStyle: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Generate multiple plans (default behavior)
  case unspecified // = 0

  /// Budget-friendly, cost-effective plan
  case budget // = 1

  /// Classic, well-rounded plan
  case balanced // = 2

  /// Luxury, high-end plan
  case premium // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .budget
    case 2: self = .balanced
    case 3: self = .premium
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .budget: return 1
    case .balanced: return 2
    case .premium: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Rushday_V1_TargetPlanStyle] = [
    .unspecified,
    .budget,
    .balanced,
    .premium,
  ]

}

public enum Rushday_V1_ChatTopic: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case general // = 1
  case venue // = 2
  case catering // = 3
  case decor // = 4
  case budget // = 5
  case music // = 6
  case photoVideo // = 7
  case entertainment // = 8
  case timeline // = 9
  case invitations // = 10
  case transport // = 11
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .general
    case 2: self = .venue
    case 3: self = .catering
    case 4: self = .decor
    case 5: self = .budget
    case 6: self = .music
    case 7: self = .photoVideo
    case 8: self = .entertainment
    case 9: self = .timeline
    case 10: self = .invitations
    case 11: self = .transport
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .general: return 1
    case .venue: return 2
    case .catering: return 3
    case .decor: return 4
    case .budget: return 5
    case .music: return 6
    case .photoVideo: return 7
    case .entertainment: return 8
    case .timeline: return 9
    case .invitations: return 10
    case .transport: return 11
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Rushday_V1_ChatTopic] = [
    .unspecified,
    .general,
    .venue,
    .catering,
    .decor,
    .budget,
    .music,
    .photoVideo,
    .entertainment,
    .timeline,
    .invitations,
    .transport,
  ]

}

public enum Rushday_V1_ChatMessageRole: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case user // = 1
  case assistant // = 2
  case system // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .user
    case 2: self = .assistant
    case 3: self = .system
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .user: return 1
    case .assistant: return 2
    case .system: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Rushday_V1_ChatMessageRole] = [
    .unspecified,
    .user,
    .assistant,
    .system,
  ]

}

/// Action types the AI can suggest
public enum Rushday_V1_SuggestedActionType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case none // = 0

  /// Tasks
  case addTasks // = 1

  /// Remove items from task list
  case removeTasks // = 5

  /// Update existing tasks
  case updateTasks // = 6

  /// Agenda
  case addAgenda // = 2

  /// Remove items from agenda
  case removeAgenda // = 7

  /// Update existing agenda items
  case updateAgenda // = 8

  /// Expenses
  case addExpenses // = 3

  /// Remove items from expenses
  case removeExpenses // = 9

  /// Update existing expenses
  case updateExpenses // = 10

  /// Legacy
  case updateBudget // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .addTasks
    case 2: self = .addAgenda
    case 3: self = .addExpenses
    case 4: self = .updateBudget
    case 5: self = .removeTasks
    case 6: self = .updateTasks
    case 7: self = .removeAgenda
    case 8: self = .updateAgenda
    case 9: self = .removeExpenses
    case 10: self = .updateExpenses
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .addTasks: return 1
    case .addAgenda: return 2
    case .addExpenses: return 3
    case .updateBudget: return 4
    case .removeTasks: return 5
    case .updateTasks: return 6
    case .removeAgenda: return 7
    case .updateAgenda: return 8
    case .removeExpenses: return 9
    case .updateExpenses: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Rushday_V1_SuggestedActionType] = [
    .none,
    .addTasks,
    .removeTasks,
    .updateTasks,
    .addAgenda,
    .removeAgenda,
    .updateAgenda,
    .addExpenses,
    .removeExpenses,
    .updateExpenses,
    .updateBudget,
  ]

}

public struct Rushday_V1_GenerateEventPlansRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Step 1: Event Type
  public var eventType: Rushday_V1_AIEventType {
    get {return _storage._eventType}
    set {_uniqueStorage()._eventType = newValue}
  }

  /// If event_type is OTHER
  public var customEventType: String {
    get {return _storage._customEventType}
    set {_uniqueStorage()._customEventType = newValue}
  }

  /// Step 2: Guest Count
  public var guestRange: Rushday_V1_GuestCountRange {
    get {return _storage._guestRange}
    set {_uniqueStorage()._guestRange = newValue}
  }

  /// Optional custom count
  public var customGuestCount: Int32 {
    get {return _storage._customGuestCount}
    set {_uniqueStorage()._customGuestCount = newValue}
  }

  /// Step 3: Event Details
  public var eventName: String {
    get {return _storage._eventName}
    set {_uniqueStorage()._eventName = newValue}
  }

  public var startDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startDate = newValue}
  }
  /// Returns true if `startDate` has been explicitly set.
  public var hasStartDate: Bool {return _storage._startDate != nil}
  /// Clears the value of `startDate`. Subsequent reads from it will return its default value.
  public mutating func clearStartDate() {_uniqueStorage()._startDate = nil}

  public var endDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endDate = newValue}
  }
  /// Returns true if `endDate` has been explicitly set.
  public var hasEndDate: Bool {return _storage._endDate != nil}
  /// Clears the value of `endDate`. Subsequent reads from it will return its default value.
  public mutating func clearEndDate() {_uniqueStorage()._endDate = nil}

  public var venueLocation: String {
    get {return _storage._venueLocation}
    set {_uniqueStorage()._venueLocation = newValue}
  }

  /// Step 4: Venue Type
  public var venueType: Rushday_V1_VenueType {
    get {return _storage._venueType}
    set {_uniqueStorage()._venueType = newValue}
  }

  public var customVenueName: String {
    get {return _storage._customVenueName}
    set {_uniqueStorage()._customVenueName = newValue}
  }

  public var venueSkipped: Bool {
    get {return _storage._venueSkipped}
    set {_uniqueStorage()._venueSkipped = newValue}
  }

  /// Step 5: Budget
  public var budgetTier: Rushday_V1_BudgetTier {
    get {return _storage._budgetTier}
    set {_uniqueStorage()._budgetTier = newValue}
  }

  /// Optional custom amount
  public var customBudgetAmount: Int32 {
    get {return _storage._customBudgetAmount}
    set {_uniqueStorage()._customBudgetAmount = newValue}
  }

  /// Step 6: Services
  public var selectedServices: [Rushday_V1_ServiceType] {
    get {return _storage._selectedServices}
    set {_uniqueStorage()._selectedServices = newValue}
  }

  public var customService: String {
    get {return _storage._customService}
    set {_uniqueStorage()._customService = newValue}
  }

  public var servicesSkipped: Bool {
    get {return _storage._servicesSkipped}
    set {_uniqueStorage()._servicesSkipped = newValue}
  }

  /// Step 7: Preferences
  public var preferencesText: String {
    get {return _storage._preferencesText}
    set {_uniqueStorage()._preferencesText = newValue}
  }

  public var selectedTags: [String] {
    get {return _storage._selectedTags}
    set {_uniqueStorage()._selectedTags = newValue}
  }

  public var preferencesSkipped: Bool {
    get {return _storage._preferencesSkipped}
    set {_uniqueStorage()._preferencesSkipped = newValue}
  }

  /// Additional adjustment (from results page)
  public var adjustmentText: String {
    get {return _storage._adjustmentText}
    set {_uniqueStorage()._adjustmentText = newValue}
  }

  /// Include full details in response (skips need for GetPlanDetails call)
  public var includeTasks: Bool {
    get {return _storage._includeTasks}
    set {_uniqueStorage()._includeTasks = newValue}
  }

  public var includeAgenda: Bool {
    get {return _storage._includeAgenda}
    set {_uniqueStorage()._includeAgenda = newValue}
  }

  public var includeVendors: Bool {
    get {return _storage._includeVendors}
    set {_uniqueStorage()._includeVendors = newValue}
  }

  /// Target style for single-plan generation (parallel requests)
  /// If set (not UNSPECIFIED), generates exactly 1 plan matching this style
  /// If not set, generates 3 plans as before (legacy behavior)
  public var targetPlanStyle: Rushday_V1_TargetPlanStyle {
    get {return _storage._targetPlanStyle}
    set {_uniqueStorage()._targetPlanStyle = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rushday_V1_GenerateEventPlansResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var generationID: String = String()

  public var processingTimeMs: Int64 = 0

  public var plans: [Rushday_V1_EventPlan] = []

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_GetGeneratedPlansRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var generationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_CreateEventFromPlanRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var generationID: String = String()

  public var planID: String = String()

  public var createTasks: Bool = false

  public var createAgenda: Bool = false

  public var createBudgetItems: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_CreateEventFromPlanResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var eventID: String = String()

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_GetPlanDetailsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var generationID: String = String()

  public var planID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_GetPlanDetailsResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool {
    get {return _storage._success}
    set {_uniqueStorage()._success = newValue}
  }

  public var plan: Rushday_V1_EventPlan {
    get {return _storage._plan ?? Rushday_V1_EventPlan()}
    set {_uniqueStorage()._plan = newValue}
  }
  /// Returns true if `plan` has been explicitly set.
  public var hasPlan: Bool {return _storage._plan != nil}
  /// Clears the value of `plan`. Subsequent reads from it will return its default value.
  public mutating func clearPlan() {_uniqueStorage()._plan = nil}

  public var errorMessage: String {
    get {return _storage._errorMessage}
    set {_uniqueStorage()._errorMessage = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rushday_V1_GenerateEventPlansStreamResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Rushday_V1_GenerateEventPlansStreamResponse.OneOf_Payload? = nil

  public var progress: Rushday_V1_GenerationProgress {
    get {
      if case .progress(let v)? = payload {return v}
      return Rushday_V1_GenerationProgress()
    }
    set {payload = .progress(newValue)}
  }

  /// Light summary for cards
  public var planSummary: Rushday_V1_EventPlanSummary {
    get {
      if case .planSummary(let v)? = payload {return v}
      return Rushday_V1_EventPlanSummary()
    }
    set {payload = .planSummary(newValue)}
  }

  public var complete: Rushday_V1_GenerationComplete {
    get {
      if case .complete(let v)? = payload {return v}
      return Rushday_V1_GenerationComplete()
    }
    set {payload = .complete(newValue)}
  }

  public var error: Rushday_V1_GenerationError {
    get {
      if case .error(let v)? = payload {return v}
      return Rushday_V1_GenerationError()
    }
    set {payload = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable, Sendable {
    case progress(Rushday_V1_GenerationProgress)
    /// Light summary for cards
    case planSummary(Rushday_V1_EventPlanSummary)
    case complete(Rushday_V1_GenerationComplete)
    case error(Rushday_V1_GenerationError)

  }

  public init() {}
}

public struct Rushday_V1_GenerationProgress: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// "analyzing", "generating", "optimizing"
  public var step: String = String()

  /// 0-100
  public var percentage: Int32 = 0

  /// Human-readable message
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_GenerationComplete: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var generationID: String = String()

  public var totalPlans: Int32 = 0

  public var processingTimeMs: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_GenerationError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: String = String()

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Light summary for results cards (Step 1)
/// Can optionally include full details if include_* flags are set in request
public struct Rushday_V1_EventPlanSummary: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var title: String = String()

  public var description_p: String = String()

  public var tier: Rushday_V1_PlanTier = .unspecified

  public var style: Rushday_V1_PlanStyle = .unspecified

  public var matchScore: Int32 = 0

  public var estimatedBudget: Rushday_V1_BudgetRange {
    get {return _estimatedBudget ?? Rushday_V1_BudgetRange()}
    set {_estimatedBudget = newValue}
  }
  /// Returns true if `estimatedBudget` has been explicitly set.
  public var hasEstimatedBudget: Bool {return self._estimatedBudget != nil}
  /// Clears the value of `estimatedBudget`. Subsequent reads from it will return its default value.
  public mutating func clearEstimatedBudget() {self._estimatedBudget = nil}

  public var highlights: [String] = []

  /// Short descriptions for card preview
  public var venueDescription: String = String()

  public var cateringDescription: String = String()

  public var entertainmentDescription: String = String()

  /// Optional detailed items (populated when include_* flags are set)
  public var suggestedVendors: [Rushday_V1_SuggestedVendor] = []

  public var suggestedTasks: [Rushday_V1_SuggestedTask] = []

  public var suggestedAgenda: [Rushday_V1_SuggestedAgendaItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _estimatedBudget: Rushday_V1_BudgetRange? = nil
}

/// Full plan details (Step 2 - on demand)
public struct Rushday_V1_EventPlan: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var title: String = String()

  public var description_p: String = String()

  public var tier: Rushday_V1_PlanTier = .unspecified

  public var style: Rushday_V1_PlanStyle = .unspecified

  /// 0-100 percentage
  public var matchScore: Int32 = 0

  /// Budget
  public var estimatedBudget: Rushday_V1_BudgetRange {
    get {return _estimatedBudget ?? Rushday_V1_BudgetRange()}
    set {_estimatedBudget = newValue}
  }
  /// Returns true if `estimatedBudget` has been explicitly set.
  public var hasEstimatedBudget: Bool {return self._estimatedBudget != nil}
  /// Clears the value of `estimatedBudget`. Subsequent reads from it will return its default value.
  public mutating func clearEstimatedBudget() {self._estimatedBudget = nil}

  /// Highlights
  public var highlights: [String] = []

  /// Descriptions
  public var venueDescription: String = String()

  public var cateringDescription: String = String()

  public var entertainmentDescription: String = String()

  /// Suggested items
  public var suggestedVendors: [Rushday_V1_SuggestedVendor] = []

  public var suggestedTasks: [Rushday_V1_SuggestedTask] = []

  public var suggestedAgenda: [Rushday_V1_SuggestedAgendaItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _estimatedBudget: Rushday_V1_BudgetRange? = nil
}

public struct Rushday_V1_BudgetRange: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var minAmount: Int32 = 0

  public var maxAmount: Int32 = 0

  public var currency: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_SuggestedVendor: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var name: String = String()

  public var category: String = String()

  public var estimatedCost: Int32 = 0

  public var rating: Double = 0

  public var imageURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_SuggestedTask: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var title: String = String()

  public var description_p: String = String()

  public var daysBeforeEvent: Int32 = 0

  public var priority: String = String()

  public var category: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_SuggestedAgendaItem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var title: String = String()

  public var description_p: String = String()

  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  public var durationMinutes: Int32 = 0

  public var location: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Rushday_V1_GenerateAgendaRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventID: String = String()

  /// true = delete old items first, false = append
  public var replaceExisting: Bool = false

  /// Titles already in the list (to avoid duplicates)
  public var existingTitles: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_GenerateAgendaResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var agendaItems: [Rushday_V1_GeneratedAgendaItem] = []

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_GeneratedAgendaItem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var title: String = String()

  public var description_p: String = String()

  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  public var durationMinutes: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Rushday_V1_GenerateExpensesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventID: String = String()

  /// true = delete old items first, false = append
  public var replaceExisting: Bool = false

  /// Current agenda activity titles (for context when generating expenses)
  public var currentAgendaItems: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_GenerateExpensesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var expenseItems: [Rushday_V1_GeneratedExpenseItem] = []

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_GeneratedExpenseItem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var title: String = String()

  public var category: String = String()

  public var estimatedCost: Int64 = 0

  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_CreateAIDraftEventRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var eventType: String = String()

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  /// Planned budget amount (for backwards compatibility, use budget_max if set)
  public var budgetPlan: Int64 = 0

  /// Planned guest count
  public var guestsPlan: Int32 = 0

  /// Optional cover image URL
  public var coverImage: String = String()

  /// Device/session ID for anonymous drafts (used to claim later)
  public var sessionID: String = String()

  /// Minimum budget amount (from tier range)
  public var budgetMin: Int64 = 0

  /// Maximum budget amount (from tier range)
  public var budgetMax: Int64 = 0

  /// Venue/location name (e.g., "Tashkent")
  public var venue: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Rushday_V1_CreateAIDraftEventResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var eventID: String = String()

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_PublishAIDraftEventRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventID: String = String()

  /// Required if draft was created anonymously
  public var sessionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_PublishAIDraftEventResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var eventID: String = String()

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_ClaimDraftEventRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Draft event ID to claim
  public var eventID: String = String()

  /// Session ID that was used to create the draft
  public var sessionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_ClaimDraftEventResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var eventID: String = String()

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_GenerateInviteMessageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_GenerateInviteMessageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var message: String = String()

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_SendChatMessageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventID: String = String()

  public var message: String = String()

  /// Optional: context topic for the conversation
  public var topic: Rushday_V1_ChatTopic = .unspecified

  /// Optional: to continue existing conversation
  public var conversationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_SendChatMessageResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool {
    get {return _storage._success}
    set {_uniqueStorage()._success = newValue}
  }

  public var conversationID: String {
    get {return _storage._conversationID}
    set {_uniqueStorage()._conversationID = newValue}
  }

  public var responseMessage: Rushday_V1_ChatMessage {
    get {return _storage._responseMessage ?? Rushday_V1_ChatMessage()}
    set {_uniqueStorage()._responseMessage = newValue}
  }
  /// Returns true if `responseMessage` has been explicitly set.
  public var hasResponseMessage: Bool {return _storage._responseMessage != nil}
  /// Clears the value of `responseMessage`. Subsequent reads from it will return its default value.
  public mutating func clearResponseMessage() {_uniqueStorage()._responseMessage = nil}

  /// Optional: if AI generates a checklist
  public var checklist: Rushday_V1_ChatChecklist {
    get {return _storage._checklist ?? Rushday_V1_ChatChecklist()}
    set {_uniqueStorage()._checklist = newValue}
  }
  /// Returns true if `checklist` has been explicitly set.
  public var hasChecklist: Bool {return _storage._checklist != nil}
  /// Clears the value of `checklist`. Subsequent reads from it will return its default value.
  public mutating func clearChecklist() {_uniqueStorage()._checklist = nil}

  /// Follow-up topic suggestions
  public var suggestedTopics: [String] {
    get {return _storage._suggestedTopics}
    set {_uniqueStorage()._suggestedTopics = newValue}
  }

  public var errorMessage: String {
    get {return _storage._errorMessage}
    set {_uniqueStorage()._errorMessage = newValue}
  }

  /// Contextual hint for the input field placeholder
  public var hintText: String {
    get {return _storage._hintText}
    set {_uniqueStorage()._hintText = newValue}
  }

  /// Optional: actionable suggestion (add to tasks, agenda, etc.)
  public var suggestedAction: Rushday_V1_SuggestedAction {
    get {return _storage._suggestedAction ?? Rushday_V1_SuggestedAction()}
    set {_uniqueStorage()._suggestedAction = newValue}
  }
  /// Returns true if `suggestedAction` has been explicitly set.
  public var hasSuggestedAction: Bool {return _storage._suggestedAction != nil}
  /// Clears the value of `suggestedAction`. Subsequent reads from it will return its default value.
  public mutating func clearSuggestedAction() {_uniqueStorage()._suggestedAction = nil}

  /// List of tool calls made during the response
  public var toolExecutions: [Rushday_V1_ToolExecution] {
    get {return _storage._toolExecutions}
    set {_uniqueStorage()._toolExecutions = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents a tool call that was executed during the AI response
public struct Rushday_V1_ToolExecution: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the tool called (e.g., "get_tasks", "search_web")
  public var toolName: String = String()

  /// "success", "error", or "pending_approval"
  public var status: String = String()

  /// Human-readable summary (e.g., "Found 3 tasks")
  public var summary: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Suggested action the user can take
public struct Rushday_V1_SuggestedAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actionType: Rushday_V1_SuggestedActionType = .none

  /// e.g., "Would you like me to add these to your tasks?"
  public var promptText: String = String()

  /// e.g., "Add to Tasks"
  public var confirmButtonText: String = String()

  /// e.g., "No thanks"
  public var declineButtonText: String = String()

  /// Items to add if user confirms
  public var items: [Rushday_V1_SuggestedActionItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Item that can be added/removed/updated via suggested action
public struct Rushday_V1_SuggestedActionItem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of existing item (for remove/update operations)
  public var id: String = String()

  public var title: String = String()

  public var description_p: String = String()

  /// For tasks: category, for expenses: category
  public var category: String = String()

  /// For expenses: estimated amount
  public var amount: Int64 = 0

  /// For agenda: start time (HH:MM format)
  public var startTime: String = String()

  /// For agenda: duration
  public var durationMinutes: Int32 = 0

  /// For update: new title
  public var newTitle: String = String()

  /// For update: new description
  public var newDescription: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_ChatStreamResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Rushday_V1_ChatStreamResponse.OneOf_Payload? = nil

  public var delta: Rushday_V1_ChatStreamDelta {
    get {
      if case .delta(let v)? = payload {return v}
      return Rushday_V1_ChatStreamDelta()
    }
    set {payload = .delta(newValue)}
  }

  public var complete: Rushday_V1_ChatStreamComplete {
    get {
      if case .complete(let v)? = payload {return v}
      return Rushday_V1_ChatStreamComplete()
    }
    set {payload = .complete(newValue)}
  }

  public var error: Rushday_V1_ChatStreamError {
    get {
      if case .error(let v)? = payload {return v}
      return Rushday_V1_ChatStreamError()
    }
    set {payload = .error(newValue)}
  }

  /// Real-time tool execution updates
  public var toolExecution: Rushday_V1_ChatStreamToolExecution {
    get {
      if case .toolExecution(let v)? = payload {return v}
      return Rushday_V1_ChatStreamToolExecution()
    }
    set {payload = .toolExecution(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable, Sendable {
    case delta(Rushday_V1_ChatStreamDelta)
    case complete(Rushday_V1_ChatStreamComplete)
    case error(Rushday_V1_ChatStreamError)
    /// Real-time tool execution updates
    case toolExecution(Rushday_V1_ChatStreamToolExecution)

  }

  public init() {}
}

/// Streamed when a tool is executed during the response
public struct Rushday_V1_ChatStreamToolExecution: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var toolName: String = String()

  /// "success", "error", "pending_approval"
  public var status: String = String()

  public var summary: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_ChatStreamDelta: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Partial text content
  public var text: String = String()

  public var conversationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_ChatStreamComplete: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversationID: String {
    get {return _storage._conversationID}
    set {_uniqueStorage()._conversationID = newValue}
  }

  public var fullMessage: Rushday_V1_ChatMessage {
    get {return _storage._fullMessage ?? Rushday_V1_ChatMessage()}
    set {_uniqueStorage()._fullMessage = newValue}
  }
  /// Returns true if `fullMessage` has been explicitly set.
  public var hasFullMessage: Bool {return _storage._fullMessage != nil}
  /// Clears the value of `fullMessage`. Subsequent reads from it will return its default value.
  public mutating func clearFullMessage() {_uniqueStorage()._fullMessage = nil}

  /// Optional: complete checklist if generated
  public var checklist: Rushday_V1_ChatChecklist {
    get {return _storage._checklist ?? Rushday_V1_ChatChecklist()}
    set {_uniqueStorage()._checklist = newValue}
  }
  /// Returns true if `checklist` has been explicitly set.
  public var hasChecklist: Bool {return _storage._checklist != nil}
  /// Clears the value of `checklist`. Subsequent reads from it will return its default value.
  public mutating func clearChecklist() {_uniqueStorage()._checklist = nil}

  public var suggestedTopics: [String] {
    get {return _storage._suggestedTopics}
    set {_uniqueStorage()._suggestedTopics = newValue}
  }

  /// Contextual hint for the input field placeholder
  public var hintText: String {
    get {return _storage._hintText}
    set {_uniqueStorage()._hintText = newValue}
  }

  /// Optional: action for user approval
  public var suggestedAction: Rushday_V1_SuggestedAction {
    get {return _storage._suggestedAction ?? Rushday_V1_SuggestedAction()}
    set {_uniqueStorage()._suggestedAction = newValue}
  }
  /// Returns true if `suggestedAction` has been explicitly set.
  public var hasSuggestedAction: Bool {return _storage._suggestedAction != nil}
  /// Clears the value of `suggestedAction`. Subsequent reads from it will return its default value.
  public mutating func clearSuggestedAction() {_uniqueStorage()._suggestedAction = nil}

  /// Tools executed during response
  public var toolExecutions: [Rushday_V1_ToolExecution] {
    get {return _storage._toolExecutions}
    set {_uniqueStorage()._toolExecutions = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rushday_V1_ChatStreamError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: String = String()

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_ChatMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var conversationID: String = String()

  public var role: Rushday_V1_ChatMessageRole = .unspecified

  public var content: String = String()

  public var topic: Rushday_V1_ChatTopic = .unspecified

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// Optional: associated checklist
  public var checklist: Rushday_V1_ChatChecklist {
    get {return _checklist ?? Rushday_V1_ChatChecklist()}
    set {_checklist = newValue}
  }
  /// Returns true if `checklist` has been explicitly set.
  public var hasChecklist: Bool {return self._checklist != nil}
  /// Clears the value of `checklist`. Subsequent reads from it will return its default value.
  public mutating func clearChecklist() {self._checklist = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _checklist: Rushday_V1_ChatChecklist? = nil
}

public struct Rushday_V1_ChatChecklist: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var title: String = String()

  public var description_p: String = String()

  public var topic: Rushday_V1_ChatTopic = .unspecified

  public var items: [Rushday_V1_ChatChecklistItem] = []

  /// Whether the checklist is saved to the event
  public var isSaved: Bool = false

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// Conversation this checklist belongs to
  public var conversationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Rushday_V1_ChatChecklistItem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var text: String = String()

  public var isChecked: Bool = false

  /// Display order
  public var order: Int32 = 0

  /// Optional user notes
  public var notes: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_GenerateTopicChecklistRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventID: String = String()

  public var topic: Rushday_V1_ChatTopic = .unspecified

  /// Optional: custom user prompt for context
  public var customPrompt: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_GenerateTopicChecklistResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool {
    get {return _storage._success}
    set {_uniqueStorage()._success = newValue}
  }

  public var checklist: Rushday_V1_ChatChecklist {
    get {return _storage._checklist ?? Rushday_V1_ChatChecklist()}
    set {_uniqueStorage()._checklist = newValue}
  }
  /// Returns true if `checklist` has been explicitly set.
  public var hasChecklist: Bool {return _storage._checklist != nil}
  /// Clears the value of `checklist`. Subsequent reads from it will return its default value.
  public mutating func clearChecklist() {_uniqueStorage()._checklist = nil}

  public var errorMessage: String {
    get {return _storage._errorMessage}
    set {_uniqueStorage()._errorMessage = newValue}
  }

  /// AI assistant message with the checklist attached
  public var message: Rushday_V1_ChatMessage {
    get {return _storage._message ?? Rushday_V1_ChatMessage()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {_uniqueStorage()._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rushday_V1_SaveChecklistRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventID: String = String()

  public var checklistID: String = String()

  /// Updated items to save
  public var items: [Rushday_V1_ChatChecklistItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_SaveChecklistResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var checklistID: String = String()

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_UnsaveChecklistRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventID: String = String()

  public var checklistID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_UnsaveChecklistResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_GetChatHistoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventID: String = String()

  /// Optional: specific conversation
  public var conversationID: String = String()

  /// Optional: filter by topic
  public var topic: Rushday_V1_ChatTopic = .unspecified

  /// Max messages to return (default 50)
  public var limit: Int32 = 0

  /// Pagination cursor
  public var cursor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_GetChatHistoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var messages: [Rushday_V1_ChatMessage] = []

  public var nextCursor: String = String()

  public var hasMore_p: Bool = false

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_GetSavedChecklistsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventID: String = String()

  /// Optional: filter by topic
  public var topic: Rushday_V1_ChatTopic = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_GetSavedChecklistsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var checklists: [Rushday_V1_ChatChecklist] = []

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_SaveConversationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventID: String = String()

  public var conversationID: String = String()

  /// Optional: custom title for the saved conversation
  public var title: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_SaveConversationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var conversation: Rushday_V1_SavedConversation {
    get {return _conversation ?? Rushday_V1_SavedConversation()}
    set {_conversation = newValue}
  }
  /// Returns true if `conversation` has been explicitly set.
  public var hasConversation: Bool {return self._conversation != nil}
  /// Clears the value of `conversation`. Subsequent reads from it will return its default value.
  public mutating func clearConversation() {self._conversation = nil}

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _conversation: Rushday_V1_SavedConversation? = nil
}

public struct Rushday_V1_UnsaveConversationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventID: String = String()

  public var conversationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_UnsaveConversationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_GetSavedConversationsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_GetSavedConversationsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var conversations: [Rushday_V1_SavedConversation] = []

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents a saved conversation
public struct Rushday_V1_SavedConversation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var eventID: String = String()

  public var conversationID: String = String()

  /// Auto-generated or custom title
  public var title: String = String()

  /// First message or summary
  public var preview: String = String()

  public var messageCount: Int32 = 0

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var savedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _savedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_savedAt = newValue}
  }
  /// Returns true if `savedAt` has been explicitly set.
  public var hasSavedAt: Bool {return self._savedAt != nil}
  /// Clears the value of `savedAt`. Subsequent reads from it will return its default value.
  public mutating func clearSavedAt() {self._savedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _savedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Rushday_V1_UpdateChecklistItemRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventID: String = String()

  public var checklistID: String = String()

  public var itemID: String = String()

  public var isChecked: Bool = false

  /// Optional: update notes
  public var notes: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_UpdateChecklistItemResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var updatedItem: Rushday_V1_ChatChecklistItem {
    get {return _updatedItem ?? Rushday_V1_ChatChecklistItem()}
    set {_updatedItem = newValue}
  }
  /// Returns true if `updatedItem` has been explicitly set.
  public var hasUpdatedItem: Bool {return self._updatedItem != nil}
  /// Clears the value of `updatedItem`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedItem() {self._updatedItem = nil}

  /// Total completed items in checklist
  public var completedCount: Int32 = 0

  /// Total items in checklist
  public var totalCount: Int32 = 0

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updatedItem: Rushday_V1_ChatChecklistItem? = nil
}

public struct Rushday_V1_GetChatHintsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventID: String = String()

  /// Optional: for context-aware hints based on conversation
  public var conversationID: String = String()

  /// Optional: last topic discussed for relevance
  public var lastTopic: Rushday_V1_ChatTopic = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rushday_V1_GetChatHintsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  /// Main hint text for input placeholder
  public var primaryHint: String = String()

  /// Alternative hints for rotation
  public var suggestedHints: [String] = []

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rushday.v1"

extension Rushday_V1_AIEventType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0AI_EVENT_TYPE_UNSPECIFIED\0\u{1}AI_EVENT_TYPE_BIRTHDAY\0\u{1}AI_EVENT_TYPE_WEDDING\0\u{1}AI_EVENT_TYPE_BUSINESS\0\u{1}AI_EVENT_TYPE_BABY_SHOWER\0\u{1}AI_EVENT_TYPE_GRADUATION\0\u{1}AI_EVENT_TYPE_ENGAGEMENT\0\u{1}AI_EVENT_TYPE_ANNIVERSARY\0\u{1}AI_EVENT_TYPE_OTHER\0")
}

extension Rushday_V1_GuestCountRange: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0GUEST_COUNT_RANGE_UNSPECIFIED\0\u{1}GUEST_COUNT_RANGE_INTIMATE\0\u{1}GUEST_COUNT_RANGE_SMALL\0\u{1}GUEST_COUNT_RANGE_MEDIUM\0\u{1}GUEST_COUNT_RANGE_LARGE\0\u{1}GUEST_COUNT_RANGE_MASSIVE\0")
}

extension Rushday_V1_VenueType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0VENUE_TYPE_UNSPECIFIED\0\u{1}VENUE_TYPE_INDOOR_VENUE\0\u{1}VENUE_TYPE_OUTDOOR_SPACE\0\u{1}VENUE_TYPE_AT_HOME\0\u{1}VENUE_TYPE_HOTEL\0")
}

extension Rushday_V1_BudgetTier: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0BUDGET_TIER_UNSPECIFIED\0\u{1}BUDGET_TIER_ECONOMY\0\u{1}BUDGET_TIER_STANDARD\0\u{1}BUDGET_TIER_PREMIUM\0\u{1}BUDGET_TIER_LUXURY\0")
}

extension Rushday_V1_ServiceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SERVICE_TYPE_UNSPECIFIED\0\u{1}SERVICE_TYPE_CATERING\0\u{1}SERVICE_TYPE_DECORATION\0\u{1}SERVICE_TYPE_ENTERTAINMENT\0\u{1}SERVICE_TYPE_PHOTO_VIDEO\0\u{1}SERVICE_TYPE_INVITATIONS\0\u{1}SERVICE_TYPE_TRANSPORT\0")
}

extension Rushday_V1_PlanTier: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PLAN_TIER_UNSPECIFIED\0\u{1}PLAN_TIER_AI_RECOMMENDED\0\u{1}PLAN_TIER_POPULAR\0\u{1}PLAN_TIER_STANDARD\0")
}

extension Rushday_V1_PlanStyle: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PLAN_STYLE_UNSPECIFIED\0\u{1}PLAN_STYLE_CLASSIC\0\u{1}PLAN_STYLE_MODERN\0\u{1}PLAN_STYLE_NATURAL\0\u{1}PLAN_STYLE_LUXURY\0\u{1}PLAN_STYLE_CUSTOM\0")
}

extension Rushday_V1_TargetPlanStyle: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TARGET_PLAN_STYLE_UNSPECIFIED\0\u{1}TARGET_PLAN_STYLE_BUDGET\0\u{1}TARGET_PLAN_STYLE_BALANCED\0\u{1}TARGET_PLAN_STYLE_PREMIUM\0")
}

extension Rushday_V1_ChatTopic: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CHAT_TOPIC_UNSPECIFIED\0\u{1}CHAT_TOPIC_GENERAL\0\u{1}CHAT_TOPIC_VENUE\0\u{1}CHAT_TOPIC_CATERING\0\u{1}CHAT_TOPIC_DECOR\0\u{1}CHAT_TOPIC_BUDGET\0\u{1}CHAT_TOPIC_MUSIC\0\u{1}CHAT_TOPIC_PHOTO_VIDEO\0\u{1}CHAT_TOPIC_ENTERTAINMENT\0\u{1}CHAT_TOPIC_TIMELINE\0\u{1}CHAT_TOPIC_INVITATIONS\0\u{1}CHAT_TOPIC_TRANSPORT\0")
}

extension Rushday_V1_ChatMessageRole: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CHAT_MESSAGE_ROLE_UNSPECIFIED\0\u{1}CHAT_MESSAGE_ROLE_USER\0\u{1}CHAT_MESSAGE_ROLE_ASSISTANT\0\u{1}CHAT_MESSAGE_ROLE_SYSTEM\0")
}

extension Rushday_V1_SuggestedActionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SUGGESTED_ACTION_TYPE_NONE\0\u{1}SUGGESTED_ACTION_TYPE_ADD_TASKS\0\u{1}SUGGESTED_ACTION_TYPE_ADD_AGENDA\0\u{1}SUGGESTED_ACTION_TYPE_ADD_EXPENSES\0\u{1}SUGGESTED_ACTION_TYPE_UPDATE_BUDGET\0\u{1}SUGGESTED_ACTION_TYPE_REMOVE_TASKS\0\u{1}SUGGESTED_ACTION_TYPE_UPDATE_TASKS\0\u{1}SUGGESTED_ACTION_TYPE_REMOVE_AGENDA\0\u{1}SUGGESTED_ACTION_TYPE_UPDATE_AGENDA\0\u{1}SUGGESTED_ACTION_TYPE_REMOVE_EXPENSES\0\u{1}SUGGESTED_ACTION_TYPE_UPDATE_EXPENSES\0")
}

extension Rushday_V1_GenerateEventPlansRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateEventPlansRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_type\0\u{3}custom_event_type\0\u{3}guest_range\0\u{3}custom_guest_count\0\u{3}event_name\0\u{3}start_date\0\u{3}end_date\0\u{3}venue_location\0\u{3}venue_type\0\u{3}custom_venue_name\0\u{3}venue_skipped\0\u{3}budget_tier\0\u{3}custom_budget_amount\0\u{3}selected_services\0\u{3}custom_service\0\u{3}services_skipped\0\u{3}preferences_text\0\u{3}selected_tags\0\u{3}preferences_skipped\0\u{3}adjustment_text\0\u{3}include_tasks\0\u{3}include_agenda\0\u{3}include_vendors\0\u{3}target_plan_style\0")

  fileprivate class _StorageClass {
    var _eventType: Rushday_V1_AIEventType = .unspecified
    var _customEventType: String = String()
    var _guestRange: Rushday_V1_GuestCountRange = .unspecified
    var _customGuestCount: Int32 = 0
    var _eventName: String = String()
    var _startDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _venueLocation: String = String()
    var _venueType: Rushday_V1_VenueType = .unspecified
    var _customVenueName: String = String()
    var _venueSkipped: Bool = false
    var _budgetTier: Rushday_V1_BudgetTier = .unspecified
    var _customBudgetAmount: Int32 = 0
    var _selectedServices: [Rushday_V1_ServiceType] = []
    var _customService: String = String()
    var _servicesSkipped: Bool = false
    var _preferencesText: String = String()
    var _selectedTags: [String] = []
    var _preferencesSkipped: Bool = false
    var _adjustmentText: String = String()
    var _includeTasks: Bool = false
    var _includeAgenda: Bool = false
    var _includeVendors: Bool = false
    var _targetPlanStyle: Rushday_V1_TargetPlanStyle = .unspecified

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _eventType = source._eventType
      _customEventType = source._customEventType
      _guestRange = source._guestRange
      _customGuestCount = source._customGuestCount
      _eventName = source._eventName
      _startDate = source._startDate
      _endDate = source._endDate
      _venueLocation = source._venueLocation
      _venueType = source._venueType
      _customVenueName = source._customVenueName
      _venueSkipped = source._venueSkipped
      _budgetTier = source._budgetTier
      _customBudgetAmount = source._customBudgetAmount
      _selectedServices = source._selectedServices
      _customService = source._customService
      _servicesSkipped = source._servicesSkipped
      _preferencesText = source._preferencesText
      _selectedTags = source._selectedTags
      _preferencesSkipped = source._preferencesSkipped
      _adjustmentText = source._adjustmentText
      _includeTasks = source._includeTasks
      _includeAgenda = source._includeAgenda
      _includeVendors = source._includeVendors
      _targetPlanStyle = source._targetPlanStyle
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._eventType) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._customEventType) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._guestRange) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._customGuestCount) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._eventName) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._startDate) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._endDate) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._venueLocation) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._venueType) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._customVenueName) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._venueSkipped) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._budgetTier) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._customBudgetAmount) }()
        case 14: try { try decoder.decodeRepeatedEnumField(value: &_storage._selectedServices) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._customService) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._servicesSkipped) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._preferencesText) }()
        case 18: try { try decoder.decodeRepeatedStringField(value: &_storage._selectedTags) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._preferencesSkipped) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._adjustmentText) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._includeTasks) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._includeAgenda) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._includeVendors) }()
        case 24: try { try decoder.decodeSingularEnumField(value: &_storage._targetPlanStyle) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._eventType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._eventType, fieldNumber: 1)
      }
      if !_storage._customEventType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._customEventType, fieldNumber: 2)
      }
      if _storage._guestRange != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._guestRange, fieldNumber: 3)
      }
      if _storage._customGuestCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._customGuestCount, fieldNumber: 4)
      }
      if !_storage._eventName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._eventName, fieldNumber: 5)
      }
      try { if let v = _storage._startDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._endDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._venueLocation.isEmpty {
        try visitor.visitSingularStringField(value: _storage._venueLocation, fieldNumber: 8)
      }
      if _storage._venueType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._venueType, fieldNumber: 9)
      }
      if !_storage._customVenueName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._customVenueName, fieldNumber: 10)
      }
      if _storage._venueSkipped != false {
        try visitor.visitSingularBoolField(value: _storage._venueSkipped, fieldNumber: 11)
      }
      if _storage._budgetTier != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._budgetTier, fieldNumber: 12)
      }
      if _storage._customBudgetAmount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._customBudgetAmount, fieldNumber: 13)
      }
      if !_storage._selectedServices.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._selectedServices, fieldNumber: 14)
      }
      if !_storage._customService.isEmpty {
        try visitor.visitSingularStringField(value: _storage._customService, fieldNumber: 15)
      }
      if _storage._servicesSkipped != false {
        try visitor.visitSingularBoolField(value: _storage._servicesSkipped, fieldNumber: 16)
      }
      if !_storage._preferencesText.isEmpty {
        try visitor.visitSingularStringField(value: _storage._preferencesText, fieldNumber: 17)
      }
      if !_storage._selectedTags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._selectedTags, fieldNumber: 18)
      }
      if _storage._preferencesSkipped != false {
        try visitor.visitSingularBoolField(value: _storage._preferencesSkipped, fieldNumber: 19)
      }
      if !_storage._adjustmentText.isEmpty {
        try visitor.visitSingularStringField(value: _storage._adjustmentText, fieldNumber: 20)
      }
      if _storage._includeTasks != false {
        try visitor.visitSingularBoolField(value: _storage._includeTasks, fieldNumber: 21)
      }
      if _storage._includeAgenda != false {
        try visitor.visitSingularBoolField(value: _storage._includeAgenda, fieldNumber: 22)
      }
      if _storage._includeVendors != false {
        try visitor.visitSingularBoolField(value: _storage._includeVendors, fieldNumber: 23)
      }
      if _storage._targetPlanStyle != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._targetPlanStyle, fieldNumber: 24)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GenerateEventPlansRequest, rhs: Rushday_V1_GenerateEventPlansRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._eventType != rhs_storage._eventType {return false}
        if _storage._customEventType != rhs_storage._customEventType {return false}
        if _storage._guestRange != rhs_storage._guestRange {return false}
        if _storage._customGuestCount != rhs_storage._customGuestCount {return false}
        if _storage._eventName != rhs_storage._eventName {return false}
        if _storage._startDate != rhs_storage._startDate {return false}
        if _storage._endDate != rhs_storage._endDate {return false}
        if _storage._venueLocation != rhs_storage._venueLocation {return false}
        if _storage._venueType != rhs_storage._venueType {return false}
        if _storage._customVenueName != rhs_storage._customVenueName {return false}
        if _storage._venueSkipped != rhs_storage._venueSkipped {return false}
        if _storage._budgetTier != rhs_storage._budgetTier {return false}
        if _storage._customBudgetAmount != rhs_storage._customBudgetAmount {return false}
        if _storage._selectedServices != rhs_storage._selectedServices {return false}
        if _storage._customService != rhs_storage._customService {return false}
        if _storage._servicesSkipped != rhs_storage._servicesSkipped {return false}
        if _storage._preferencesText != rhs_storage._preferencesText {return false}
        if _storage._selectedTags != rhs_storage._selectedTags {return false}
        if _storage._preferencesSkipped != rhs_storage._preferencesSkipped {return false}
        if _storage._adjustmentText != rhs_storage._adjustmentText {return false}
        if _storage._includeTasks != rhs_storage._includeTasks {return false}
        if _storage._includeAgenda != rhs_storage._includeAgenda {return false}
        if _storage._includeVendors != rhs_storage._includeVendors {return false}
        if _storage._targetPlanStyle != rhs_storage._targetPlanStyle {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GenerateEventPlansResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateEventPlansResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}generation_id\0\u{3}processing_time_ms\0\u{1}plans\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.generationID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.processingTimeMs) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.plans) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.generationID.isEmpty {
      try visitor.visitSingularStringField(value: self.generationID, fieldNumber: 2)
    }
    if self.processingTimeMs != 0 {
      try visitor.visitSingularInt64Field(value: self.processingTimeMs, fieldNumber: 3)
    }
    if !self.plans.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.plans, fieldNumber: 4)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GenerateEventPlansResponse, rhs: Rushday_V1_GenerateEventPlansResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.generationID != rhs.generationID {return false}
    if lhs.processingTimeMs != rhs.processingTimeMs {return false}
    if lhs.plans != rhs.plans {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GetGeneratedPlansRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGeneratedPlansRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}generation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.generationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.generationID.isEmpty {
      try visitor.visitSingularStringField(value: self.generationID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GetGeneratedPlansRequest, rhs: Rushday_V1_GetGeneratedPlansRequest) -> Bool {
    if lhs.generationID != rhs.generationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_CreateEventFromPlanRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateEventFromPlanRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}generation_id\0\u{3}plan_id\0\u{3}create_tasks\0\u{3}create_agenda\0\u{3}create_budget_items\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.generationID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.planID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.createTasks) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.createAgenda) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.createBudgetItems) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.generationID.isEmpty {
      try visitor.visitSingularStringField(value: self.generationID, fieldNumber: 1)
    }
    if !self.planID.isEmpty {
      try visitor.visitSingularStringField(value: self.planID, fieldNumber: 2)
    }
    if self.createTasks != false {
      try visitor.visitSingularBoolField(value: self.createTasks, fieldNumber: 3)
    }
    if self.createAgenda != false {
      try visitor.visitSingularBoolField(value: self.createAgenda, fieldNumber: 4)
    }
    if self.createBudgetItems != false {
      try visitor.visitSingularBoolField(value: self.createBudgetItems, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_CreateEventFromPlanRequest, rhs: Rushday_V1_CreateEventFromPlanRequest) -> Bool {
    if lhs.generationID != rhs.generationID {return false}
    if lhs.planID != rhs.planID {return false}
    if lhs.createTasks != rhs.createTasks {return false}
    if lhs.createAgenda != rhs.createAgenda {return false}
    if lhs.createBudgetItems != rhs.createBudgetItems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_CreateEventFromPlanResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateEventFromPlanResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}event_id\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 2)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_CreateEventFromPlanResponse, rhs: Rushday_V1_CreateEventFromPlanResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.eventID != rhs.eventID {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GetPlanDetailsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPlanDetailsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}generation_id\0\u{3}plan_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.generationID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.planID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.generationID.isEmpty {
      try visitor.visitSingularStringField(value: self.generationID, fieldNumber: 1)
    }
    if !self.planID.isEmpty {
      try visitor.visitSingularStringField(value: self.planID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GetPlanDetailsRequest, rhs: Rushday_V1_GetPlanDetailsRequest) -> Bool {
    if lhs.generationID != rhs.generationID {return false}
    if lhs.planID != rhs.planID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GetPlanDetailsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPlanDetailsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}plan\0\u{3}error_message\0")

  fileprivate class _StorageClass {
    var _success: Bool = false
    var _plan: Rushday_V1_EventPlan? = nil
    var _errorMessage: String = String()

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _success = source._success
      _plan = source._plan
      _errorMessage = source._errorMessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._success) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._plan) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._errorMessage) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._success != false {
        try visitor.visitSingularBoolField(value: _storage._success, fieldNumber: 1)
      }
      try { if let v = _storage._plan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._errorMessage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._errorMessage, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GetPlanDetailsResponse, rhs: Rushday_V1_GetPlanDetailsResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._success != rhs_storage._success {return false}
        if _storage._plan != rhs_storage._plan {return false}
        if _storage._errorMessage != rhs_storage._errorMessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GenerateEventPlansStreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateEventPlansStreamResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}progress\0\u{3}plan_summary\0\u{1}complete\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Rushday_V1_GenerationProgress?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .progress(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .progress(v)
        }
      }()
      case 2: try {
        var v: Rushday_V1_EventPlanSummary?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .planSummary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .planSummary(v)
        }
      }()
      case 3: try {
        var v: Rushday_V1_GenerationComplete?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .complete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .complete(v)
        }
      }()
      case 4: try {
        var v: Rushday_V1_GenerationError?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .progress?: try {
      guard case .progress(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .planSummary?: try {
      guard case .planSummary(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .complete?: try {
      guard case .complete(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .error?: try {
      guard case .error(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GenerateEventPlansStreamResponse, rhs: Rushday_V1_GenerateEventPlansStreamResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GenerationProgress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerationProgress"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}step\0\u{1}percentage\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.step) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.percentage) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.step.isEmpty {
      try visitor.visitSingularStringField(value: self.step, fieldNumber: 1)
    }
    if self.percentage != 0 {
      try visitor.visitSingularInt32Field(value: self.percentage, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GenerationProgress, rhs: Rushday_V1_GenerationProgress) -> Bool {
    if lhs.step != rhs.step {return false}
    if lhs.percentage != rhs.percentage {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GenerationComplete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerationComplete"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}generation_id\0\u{3}total_plans\0\u{3}processing_time_ms\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.generationID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.totalPlans) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.processingTimeMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.generationID.isEmpty {
      try visitor.visitSingularStringField(value: self.generationID, fieldNumber: 1)
    }
    if self.totalPlans != 0 {
      try visitor.visitSingularInt32Field(value: self.totalPlans, fieldNumber: 2)
    }
    if self.processingTimeMs != 0 {
      try visitor.visitSingularInt64Field(value: self.processingTimeMs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GenerationComplete, rhs: Rushday_V1_GenerationComplete) -> Bool {
    if lhs.generationID != rhs.generationID {return false}
    if lhs.totalPlans != rhs.totalPlans {return false}
    if lhs.processingTimeMs != rhs.processingTimeMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GenerationError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerationError"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GenerationError, rhs: Rushday_V1_GenerationError) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_EventPlanSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventPlanSummary"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}title\0\u{1}description\0\u{1}tier\0\u{1}style\0\u{3}match_score\0\u{3}estimated_budget\0\u{1}highlights\0\u{3}venue_description\0\u{3}catering_description\0\u{3}entertainment_description\0\u{3}suggested_vendors\0\u{3}suggested_tasks\0\u{3}suggested_agenda\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.tier) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.style) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.matchScore) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._estimatedBudget) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.highlights) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.venueDescription) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.cateringDescription) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.entertainmentDescription) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.suggestedVendors) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.suggestedTasks) }()
      case 14: try { try decoder.decodeRepeatedMessageField(value: &self.suggestedAgenda) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.tier != .unspecified {
      try visitor.visitSingularEnumField(value: self.tier, fieldNumber: 4)
    }
    if self.style != .unspecified {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 5)
    }
    if self.matchScore != 0 {
      try visitor.visitSingularInt32Field(value: self.matchScore, fieldNumber: 6)
    }
    try { if let v = self._estimatedBudget {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.highlights.isEmpty {
      try visitor.visitRepeatedStringField(value: self.highlights, fieldNumber: 8)
    }
    if !self.venueDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.venueDescription, fieldNumber: 9)
    }
    if !self.cateringDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.cateringDescription, fieldNumber: 10)
    }
    if !self.entertainmentDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.entertainmentDescription, fieldNumber: 11)
    }
    if !self.suggestedVendors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.suggestedVendors, fieldNumber: 12)
    }
    if !self.suggestedTasks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.suggestedTasks, fieldNumber: 13)
    }
    if !self.suggestedAgenda.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.suggestedAgenda, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_EventPlanSummary, rhs: Rushday_V1_EventPlanSummary) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.tier != rhs.tier {return false}
    if lhs.style != rhs.style {return false}
    if lhs.matchScore != rhs.matchScore {return false}
    if lhs._estimatedBudget != rhs._estimatedBudget {return false}
    if lhs.highlights != rhs.highlights {return false}
    if lhs.venueDescription != rhs.venueDescription {return false}
    if lhs.cateringDescription != rhs.cateringDescription {return false}
    if lhs.entertainmentDescription != rhs.entertainmentDescription {return false}
    if lhs.suggestedVendors != rhs.suggestedVendors {return false}
    if lhs.suggestedTasks != rhs.suggestedTasks {return false}
    if lhs.suggestedAgenda != rhs.suggestedAgenda {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_EventPlan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventPlan"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}title\0\u{1}description\0\u{1}tier\0\u{1}style\0\u{3}match_score\0\u{3}estimated_budget\0\u{1}highlights\0\u{3}venue_description\0\u{3}catering_description\0\u{3}entertainment_description\0\u{3}suggested_vendors\0\u{3}suggested_tasks\0\u{3}suggested_agenda\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.tier) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.style) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.matchScore) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._estimatedBudget) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.highlights) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.venueDescription) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.cateringDescription) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.entertainmentDescription) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.suggestedVendors) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.suggestedTasks) }()
      case 14: try { try decoder.decodeRepeatedMessageField(value: &self.suggestedAgenda) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.tier != .unspecified {
      try visitor.visitSingularEnumField(value: self.tier, fieldNumber: 4)
    }
    if self.style != .unspecified {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 5)
    }
    if self.matchScore != 0 {
      try visitor.visitSingularInt32Field(value: self.matchScore, fieldNumber: 6)
    }
    try { if let v = self._estimatedBudget {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.highlights.isEmpty {
      try visitor.visitRepeatedStringField(value: self.highlights, fieldNumber: 8)
    }
    if !self.venueDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.venueDescription, fieldNumber: 9)
    }
    if !self.cateringDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.cateringDescription, fieldNumber: 10)
    }
    if !self.entertainmentDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.entertainmentDescription, fieldNumber: 11)
    }
    if !self.suggestedVendors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.suggestedVendors, fieldNumber: 12)
    }
    if !self.suggestedTasks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.suggestedTasks, fieldNumber: 13)
    }
    if !self.suggestedAgenda.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.suggestedAgenda, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_EventPlan, rhs: Rushday_V1_EventPlan) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.tier != rhs.tier {return false}
    if lhs.style != rhs.style {return false}
    if lhs.matchScore != rhs.matchScore {return false}
    if lhs._estimatedBudget != rhs._estimatedBudget {return false}
    if lhs.highlights != rhs.highlights {return false}
    if lhs.venueDescription != rhs.venueDescription {return false}
    if lhs.cateringDescription != rhs.cateringDescription {return false}
    if lhs.entertainmentDescription != rhs.entertainmentDescription {return false}
    if lhs.suggestedVendors != rhs.suggestedVendors {return false}
    if lhs.suggestedTasks != rhs.suggestedTasks {return false}
    if lhs.suggestedAgenda != rhs.suggestedAgenda {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_BudgetRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BudgetRange"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}min_amount\0\u{3}max_amount\0\u{1}currency\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.minAmount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxAmount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.currency) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minAmount != 0 {
      try visitor.visitSingularInt32Field(value: self.minAmount, fieldNumber: 1)
    }
    if self.maxAmount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxAmount, fieldNumber: 2)
    }
    if !self.currency.isEmpty {
      try visitor.visitSingularStringField(value: self.currency, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_BudgetRange, rhs: Rushday_V1_BudgetRange) -> Bool {
    if lhs.minAmount != rhs.minAmount {return false}
    if lhs.maxAmount != rhs.maxAmount {return false}
    if lhs.currency != rhs.currency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_SuggestedVendor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SuggestedVendor"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{1}category\0\u{3}estimated_cost\0\u{1}rating\0\u{3}image_url\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.category) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.estimatedCost) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.rating) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.imageURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.category.isEmpty {
      try visitor.visitSingularStringField(value: self.category, fieldNumber: 3)
    }
    if self.estimatedCost != 0 {
      try visitor.visitSingularInt32Field(value: self.estimatedCost, fieldNumber: 4)
    }
    if self.rating.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.rating, fieldNumber: 5)
    }
    if !self.imageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.imageURL, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_SuggestedVendor, rhs: Rushday_V1_SuggestedVendor) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.category != rhs.category {return false}
    if lhs.estimatedCost != rhs.estimatedCost {return false}
    if lhs.rating != rhs.rating {return false}
    if lhs.imageURL != rhs.imageURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_SuggestedTask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SuggestedTask"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}title\0\u{1}description\0\u{3}days_before_event\0\u{1}priority\0\u{1}category\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.daysBeforeEvent) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.priority) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.category) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.daysBeforeEvent != 0 {
      try visitor.visitSingularInt32Field(value: self.daysBeforeEvent, fieldNumber: 4)
    }
    if !self.priority.isEmpty {
      try visitor.visitSingularStringField(value: self.priority, fieldNumber: 5)
    }
    if !self.category.isEmpty {
      try visitor.visitSingularStringField(value: self.category, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_SuggestedTask, rhs: Rushday_V1_SuggestedTask) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.daysBeforeEvent != rhs.daysBeforeEvent {return false}
    if lhs.priority != rhs.priority {return false}
    if lhs.category != rhs.category {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_SuggestedAgendaItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SuggestedAgendaItem"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}title\0\u{1}description\0\u{3}start_time\0\u{3}duration_minutes\0\u{1}location\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.durationMinutes) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.location) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.durationMinutes != 0 {
      try visitor.visitSingularInt32Field(value: self.durationMinutes, fieldNumber: 5)
    }
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_SuggestedAgendaItem, rhs: Rushday_V1_SuggestedAgendaItem) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs.durationMinutes != rhs.durationMinutes {return false}
    if lhs.location != rhs.location {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GenerateAgendaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateAgendaRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_id\0\u{3}replace_existing\0\u{3}existing_titles\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.replaceExisting) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.existingTitles) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 1)
    }
    if self.replaceExisting != false {
      try visitor.visitSingularBoolField(value: self.replaceExisting, fieldNumber: 2)
    }
    if !self.existingTitles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.existingTitles, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GenerateAgendaRequest, rhs: Rushday_V1_GenerateAgendaRequest) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.replaceExisting != rhs.replaceExisting {return false}
    if lhs.existingTitles != rhs.existingTitles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GenerateAgendaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateAgendaResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}agenda_items\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.agendaItems) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.agendaItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.agendaItems, fieldNumber: 2)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GenerateAgendaResponse, rhs: Rushday_V1_GenerateAgendaResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.agendaItems != rhs.agendaItems {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GeneratedAgendaItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GeneratedAgendaItem"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}title\0\u{1}description\0\u{3}start_time\0\u{3}end_time\0\u{3}duration_minutes\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.durationMinutes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.durationMinutes != 0 {
      try visitor.visitSingularInt32Field(value: self.durationMinutes, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GeneratedAgendaItem, rhs: Rushday_V1_GeneratedAgendaItem) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.durationMinutes != rhs.durationMinutes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GenerateExpensesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateExpensesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_id\0\u{3}replace_existing\0\u{3}current_agenda_items\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.replaceExisting) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.currentAgendaItems) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 1)
    }
    if self.replaceExisting != false {
      try visitor.visitSingularBoolField(value: self.replaceExisting, fieldNumber: 2)
    }
    if !self.currentAgendaItems.isEmpty {
      try visitor.visitRepeatedStringField(value: self.currentAgendaItems, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GenerateExpensesRequest, rhs: Rushday_V1_GenerateExpensesRequest) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.replaceExisting != rhs.replaceExisting {return false}
    if lhs.currentAgendaItems != rhs.currentAgendaItems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GenerateExpensesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateExpensesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}expense_items\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.expenseItems) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.expenseItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.expenseItems, fieldNumber: 2)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GenerateExpensesResponse, rhs: Rushday_V1_GenerateExpensesResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.expenseItems != rhs.expenseItems {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GeneratedExpenseItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GeneratedExpenseItem"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}title\0\u{1}category\0\u{3}estimated_cost\0\u{1}description\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.category) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.estimatedCost) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.category.isEmpty {
      try visitor.visitSingularStringField(value: self.category, fieldNumber: 3)
    }
    if self.estimatedCost != 0 {
      try visitor.visitSingularInt64Field(value: self.estimatedCost, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GeneratedExpenseItem, rhs: Rushday_V1_GeneratedExpenseItem) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs.category != rhs.category {return false}
    if lhs.estimatedCost != rhs.estimatedCost {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_CreateAIDraftEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateAIDraftEventRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}event_type\0\u{1}date\0\u{3}budget_plan\0\u{3}guests_plan\0\u{3}cover_image\0\u{3}session_id\0\u{3}budget_min\0\u{3}budget_max\0\u{1}venue\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventType) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.budgetPlan) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.guestsPlan) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.coverImage) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.budgetMin) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.budgetMax) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.venue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.eventType.isEmpty {
      try visitor.visitSingularStringField(value: self.eventType, fieldNumber: 2)
    }
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.budgetPlan != 0 {
      try visitor.visitSingularInt64Field(value: self.budgetPlan, fieldNumber: 4)
    }
    if self.guestsPlan != 0 {
      try visitor.visitSingularInt32Field(value: self.guestsPlan, fieldNumber: 5)
    }
    if !self.coverImage.isEmpty {
      try visitor.visitSingularStringField(value: self.coverImage, fieldNumber: 6)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 7)
    }
    if self.budgetMin != 0 {
      try visitor.visitSingularInt64Field(value: self.budgetMin, fieldNumber: 8)
    }
    if self.budgetMax != 0 {
      try visitor.visitSingularInt64Field(value: self.budgetMax, fieldNumber: 9)
    }
    if !self.venue.isEmpty {
      try visitor.visitSingularStringField(value: self.venue, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_CreateAIDraftEventRequest, rhs: Rushday_V1_CreateAIDraftEventRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.eventType != rhs.eventType {return false}
    if lhs._date != rhs._date {return false}
    if lhs.budgetPlan != rhs.budgetPlan {return false}
    if lhs.guestsPlan != rhs.guestsPlan {return false}
    if lhs.coverImage != rhs.coverImage {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.budgetMin != rhs.budgetMin {return false}
    if lhs.budgetMax != rhs.budgetMax {return false}
    if lhs.venue != rhs.venue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_CreateAIDraftEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateAIDraftEventResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}event_id\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 2)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_CreateAIDraftEventResponse, rhs: Rushday_V1_CreateAIDraftEventResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.eventID != rhs.eventID {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_PublishAIDraftEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublishAIDraftEventRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_id\0\u{3}session_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_PublishAIDraftEventRequest, rhs: Rushday_V1_PublishAIDraftEventRequest) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_PublishAIDraftEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublishAIDraftEventResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}event_id\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 2)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_PublishAIDraftEventResponse, rhs: Rushday_V1_PublishAIDraftEventResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.eventID != rhs.eventID {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_ClaimDraftEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClaimDraftEventRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_id\0\u{3}session_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_ClaimDraftEventRequest, rhs: Rushday_V1_ClaimDraftEventRequest) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_ClaimDraftEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClaimDraftEventResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}event_id\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 2)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_ClaimDraftEventResponse, rhs: Rushday_V1_ClaimDraftEventResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.eventID != rhs.eventID {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GenerateInviteMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateInviteMessageRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GenerateInviteMessageRequest, rhs: Rushday_V1_GenerateInviteMessageRequest) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GenerateInviteMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateInviteMessageResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}message\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GenerateInviteMessageResponse, rhs: Rushday_V1_GenerateInviteMessageResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.message != rhs.message {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_SendChatMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendChatMessageRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_id\0\u{1}message\0\u{1}topic\0\u{3}conversation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.topic) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.topic != .unspecified {
      try visitor.visitSingularEnumField(value: self.topic, fieldNumber: 3)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_SendChatMessageRequest, rhs: Rushday_V1_SendChatMessageRequest) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.message != rhs.message {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_SendChatMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendChatMessageResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}conversation_id\0\u{3}response_message\0\u{1}checklist\0\u{3}suggested_topics\0\u{3}error_message\0\u{3}hint_text\0\u{3}suggested_action\0\u{3}tool_executions\0")

  fileprivate class _StorageClass {
    var _success: Bool = false
    var _conversationID: String = String()
    var _responseMessage: Rushday_V1_ChatMessage? = nil
    var _checklist: Rushday_V1_ChatChecklist? = nil
    var _suggestedTopics: [String] = []
    var _errorMessage: String = String()
    var _hintText: String = String()
    var _suggestedAction: Rushday_V1_SuggestedAction? = nil
    var _toolExecutions: [Rushday_V1_ToolExecution] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _success = source._success
      _conversationID = source._conversationID
      _responseMessage = source._responseMessage
      _checklist = source._checklist
      _suggestedTopics = source._suggestedTopics
      _errorMessage = source._errorMessage
      _hintText = source._hintText
      _suggestedAction = source._suggestedAction
      _toolExecutions = source._toolExecutions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._success) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._conversationID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._responseMessage) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._checklist) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._suggestedTopics) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._errorMessage) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._hintText) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._suggestedAction) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._toolExecutions) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._success != false {
        try visitor.visitSingularBoolField(value: _storage._success, fieldNumber: 1)
      }
      if !_storage._conversationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._conversationID, fieldNumber: 2)
      }
      try { if let v = _storage._responseMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._checklist {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._suggestedTopics.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._suggestedTopics, fieldNumber: 5)
      }
      if !_storage._errorMessage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._errorMessage, fieldNumber: 6)
      }
      if !_storage._hintText.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hintText, fieldNumber: 7)
      }
      try { if let v = _storage._suggestedAction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._toolExecutions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._toolExecutions, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_SendChatMessageResponse, rhs: Rushday_V1_SendChatMessageResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._success != rhs_storage._success {return false}
        if _storage._conversationID != rhs_storage._conversationID {return false}
        if _storage._responseMessage != rhs_storage._responseMessage {return false}
        if _storage._checklist != rhs_storage._checklist {return false}
        if _storage._suggestedTopics != rhs_storage._suggestedTopics {return false}
        if _storage._errorMessage != rhs_storage._errorMessage {return false}
        if _storage._hintText != rhs_storage._hintText {return false}
        if _storage._suggestedAction != rhs_storage._suggestedAction {return false}
        if _storage._toolExecutions != rhs_storage._toolExecutions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_ToolExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolExecution"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}tool_name\0\u{1}status\0\u{1}summary\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.toolName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.summary) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.toolName.isEmpty {
      try visitor.visitSingularStringField(value: self.toolName, fieldNumber: 1)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 2)
    }
    if !self.summary.isEmpty {
      try visitor.visitSingularStringField(value: self.summary, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_ToolExecution, rhs: Rushday_V1_ToolExecution) -> Bool {
    if lhs.toolName != rhs.toolName {return false}
    if lhs.status != rhs.status {return false}
    if lhs.summary != rhs.summary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_SuggestedAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SuggestedAction"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}action_type\0\u{3}prompt_text\0\u{3}confirm_button_text\0\u{3}decline_button_text\0\u{1}items\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.actionType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.promptText) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.confirmButtonText) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.declineButtonText) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.actionType != .none {
      try visitor.visitSingularEnumField(value: self.actionType, fieldNumber: 1)
    }
    if !self.promptText.isEmpty {
      try visitor.visitSingularStringField(value: self.promptText, fieldNumber: 2)
    }
    if !self.confirmButtonText.isEmpty {
      try visitor.visitSingularStringField(value: self.confirmButtonText, fieldNumber: 3)
    }
    if !self.declineButtonText.isEmpty {
      try visitor.visitSingularStringField(value: self.declineButtonText, fieldNumber: 4)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_SuggestedAction, rhs: Rushday_V1_SuggestedAction) -> Bool {
    if lhs.actionType != rhs.actionType {return false}
    if lhs.promptText != rhs.promptText {return false}
    if lhs.confirmButtonText != rhs.confirmButtonText {return false}
    if lhs.declineButtonText != rhs.declineButtonText {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_SuggestedActionItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SuggestedActionItem"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}title\0\u{1}description\0\u{1}category\0\u{1}amount\0\u{3}start_time\0\u{3}duration_minutes\0\u{1}id\0\u{3}new_title\0\u{3}new_description\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.category) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.startTime) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.durationMinutes) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.newTitle) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.newDescription) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.category.isEmpty {
      try visitor.visitSingularStringField(value: self.category, fieldNumber: 3)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 4)
    }
    if !self.startTime.isEmpty {
      try visitor.visitSingularStringField(value: self.startTime, fieldNumber: 5)
    }
    if self.durationMinutes != 0 {
      try visitor.visitSingularInt32Field(value: self.durationMinutes, fieldNumber: 6)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 7)
    }
    if !self.newTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.newTitle, fieldNumber: 8)
    }
    if !self.newDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.newDescription, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_SuggestedActionItem, rhs: Rushday_V1_SuggestedActionItem) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.category != rhs.category {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.startTime != rhs.startTime {return false}
    if lhs.durationMinutes != rhs.durationMinutes {return false}
    if lhs.newTitle != rhs.newTitle {return false}
    if lhs.newDescription != rhs.newDescription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_ChatStreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatStreamResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}delta\0\u{1}complete\0\u{1}error\0\u{3}tool_execution\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Rushday_V1_ChatStreamDelta?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .delta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .delta(v)
        }
      }()
      case 2: try {
        var v: Rushday_V1_ChatStreamComplete?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .complete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .complete(v)
        }
      }()
      case 3: try {
        var v: Rushday_V1_ChatStreamError?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .error(v)
        }
      }()
      case 4: try {
        var v: Rushday_V1_ChatStreamToolExecution?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .toolExecution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .toolExecution(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .delta?: try {
      guard case .delta(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .complete?: try {
      guard case .complete(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .toolExecution?: try {
      guard case .toolExecution(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_ChatStreamResponse, rhs: Rushday_V1_ChatStreamResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_ChatStreamToolExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatStreamToolExecution"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}tool_name\0\u{1}status\0\u{1}summary\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.toolName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.summary) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.toolName.isEmpty {
      try visitor.visitSingularStringField(value: self.toolName, fieldNumber: 1)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 2)
    }
    if !self.summary.isEmpty {
      try visitor.visitSingularStringField(value: self.summary, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_ChatStreamToolExecution, rhs: Rushday_V1_ChatStreamToolExecution) -> Bool {
    if lhs.toolName != rhs.toolName {return false}
    if lhs.status != rhs.status {return false}
    if lhs.summary != rhs.summary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_ChatStreamDelta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatStreamDelta"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}text\0\u{3}conversation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_ChatStreamDelta, rhs: Rushday_V1_ChatStreamDelta) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_ChatStreamComplete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatStreamComplete"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}conversation_id\0\u{3}full_message\0\u{1}checklist\0\u{3}suggested_topics\0\u{3}hint_text\0\u{3}suggested_action\0\u{3}tool_executions\0")

  fileprivate class _StorageClass {
    var _conversationID: String = String()
    var _fullMessage: Rushday_V1_ChatMessage? = nil
    var _checklist: Rushday_V1_ChatChecklist? = nil
    var _suggestedTopics: [String] = []
    var _hintText: String = String()
    var _suggestedAction: Rushday_V1_SuggestedAction? = nil
    var _toolExecutions: [Rushday_V1_ToolExecution] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _conversationID = source._conversationID
      _fullMessage = source._fullMessage
      _checklist = source._checklist
      _suggestedTopics = source._suggestedTopics
      _hintText = source._hintText
      _suggestedAction = source._suggestedAction
      _toolExecutions = source._toolExecutions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._conversationID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._fullMessage) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._checklist) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._suggestedTopics) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._hintText) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._suggestedAction) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._toolExecutions) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._conversationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._conversationID, fieldNumber: 1)
      }
      try { if let v = _storage._fullMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._checklist {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._suggestedTopics.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._suggestedTopics, fieldNumber: 4)
      }
      if !_storage._hintText.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hintText, fieldNumber: 5)
      }
      try { if let v = _storage._suggestedAction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._toolExecutions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._toolExecutions, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_ChatStreamComplete, rhs: Rushday_V1_ChatStreamComplete) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._conversationID != rhs_storage._conversationID {return false}
        if _storage._fullMessage != rhs_storage._fullMessage {return false}
        if _storage._checklist != rhs_storage._checklist {return false}
        if _storage._suggestedTopics != rhs_storage._suggestedTopics {return false}
        if _storage._hintText != rhs_storage._hintText {return false}
        if _storage._suggestedAction != rhs_storage._suggestedAction {return false}
        if _storage._toolExecutions != rhs_storage._toolExecutions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_ChatStreamError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatStreamError"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_ChatStreamError, rhs: Rushday_V1_ChatStreamError) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_ChatMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatMessage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}conversation_id\0\u{1}role\0\u{1}content\0\u{1}topic\0\u{3}created_at\0\u{1}checklist\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.topic) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._checklist) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    if self.role != .unspecified {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 3)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 4)
    }
    if self.topic != .unspecified {
      try visitor.visitSingularEnumField(value: self.topic, fieldNumber: 5)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._checklist {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_ChatMessage, rhs: Rushday_V1_ChatMessage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.role != rhs.role {return false}
    if lhs.content != rhs.content {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._checklist != rhs._checklist {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_ChatChecklist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatChecklist"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}title\0\u{1}description\0\u{1}topic\0\u{1}items\0\u{3}is_saved\0\u{3}created_at\0\u{3}conversation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.topic) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isSaved) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.topic != .unspecified {
      try visitor.visitSingularEnumField(value: self.topic, fieldNumber: 4)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 5)
    }
    if self.isSaved != false {
      try visitor.visitSingularBoolField(value: self.isSaved, fieldNumber: 6)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_ChatChecklist, rhs: Rushday_V1_ChatChecklist) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.items != rhs.items {return false}
    if lhs.isSaved != rhs.isSaved {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_ChatChecklistItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatChecklistItem"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}text\0\u{3}is_checked\0\u{1}order\0\u{1}notes\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isChecked) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.order) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.notes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    if self.isChecked != false {
      try visitor.visitSingularBoolField(value: self.isChecked, fieldNumber: 3)
    }
    if self.order != 0 {
      try visitor.visitSingularInt32Field(value: self.order, fieldNumber: 4)
    }
    if !self.notes.isEmpty {
      try visitor.visitSingularStringField(value: self.notes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_ChatChecklistItem, rhs: Rushday_V1_ChatChecklistItem) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.text != rhs.text {return false}
    if lhs.isChecked != rhs.isChecked {return false}
    if lhs.order != rhs.order {return false}
    if lhs.notes != rhs.notes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GenerateTopicChecklistRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateTopicChecklistRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_id\0\u{1}topic\0\u{3}custom_prompt\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.topic) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.customPrompt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 1)
    }
    if self.topic != .unspecified {
      try visitor.visitSingularEnumField(value: self.topic, fieldNumber: 2)
    }
    if !self.customPrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.customPrompt, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GenerateTopicChecklistRequest, rhs: Rushday_V1_GenerateTopicChecklistRequest) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.customPrompt != rhs.customPrompt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GenerateTopicChecklistResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateTopicChecklistResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}checklist\0\u{3}error_message\0\u{1}message\0")

  fileprivate class _StorageClass {
    var _success: Bool = false
    var _checklist: Rushday_V1_ChatChecklist? = nil
    var _errorMessage: String = String()
    var _message: Rushday_V1_ChatMessage? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _success = source._success
      _checklist = source._checklist
      _errorMessage = source._errorMessage
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._success) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._checklist) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._errorMessage) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._message) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._success != false {
        try visitor.visitSingularBoolField(value: _storage._success, fieldNumber: 1)
      }
      try { if let v = _storage._checklist {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._errorMessage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._errorMessage, fieldNumber: 3)
      }
      try { if let v = _storage._message {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GenerateTopicChecklistResponse, rhs: Rushday_V1_GenerateTopicChecklistResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._success != rhs_storage._success {return false}
        if _storage._checklist != rhs_storage._checklist {return false}
        if _storage._errorMessage != rhs_storage._errorMessage {return false}
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_SaveChecklistRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SaveChecklistRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_id\0\u{3}checklist_id\0\u{1}items\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.checklistID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 1)
    }
    if !self.checklistID.isEmpty {
      try visitor.visitSingularStringField(value: self.checklistID, fieldNumber: 2)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_SaveChecklistRequest, rhs: Rushday_V1_SaveChecklistRequest) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.checklistID != rhs.checklistID {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_SaveChecklistResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SaveChecklistResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}checklist_id\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.checklistID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.checklistID.isEmpty {
      try visitor.visitSingularStringField(value: self.checklistID, fieldNumber: 2)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_SaveChecklistResponse, rhs: Rushday_V1_SaveChecklistResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.checklistID != rhs.checklistID {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_UnsaveChecklistRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnsaveChecklistRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_id\0\u{3}checklist_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.checklistID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 1)
    }
    if !self.checklistID.isEmpty {
      try visitor.visitSingularStringField(value: self.checklistID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_UnsaveChecklistRequest, rhs: Rushday_V1_UnsaveChecklistRequest) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.checklistID != rhs.checklistID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_UnsaveChecklistResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnsaveChecklistResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_UnsaveChecklistResponse, rhs: Rushday_V1_UnsaveChecklistResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GetChatHistoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatHistoryRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_id\0\u{3}conversation_id\0\u{1}topic\0\u{1}limit\0\u{1}cursor\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.topic) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 1)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    if self.topic != .unspecified {
      try visitor.visitSingularEnumField(value: self.topic, fieldNumber: 3)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 4)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GetChatHistoryRequest, rhs: Rushday_V1_GetChatHistoryRequest) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GetChatHistoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatHistoryResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}messages\0\u{3}next_cursor\0\u{3}has_more\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nextCursor) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.hasMore_p) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 2)
    }
    if !self.nextCursor.isEmpty {
      try visitor.visitSingularStringField(value: self.nextCursor, fieldNumber: 3)
    }
    if self.hasMore_p != false {
      try visitor.visitSingularBoolField(value: self.hasMore_p, fieldNumber: 4)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GetChatHistoryResponse, rhs: Rushday_V1_GetChatHistoryResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.nextCursor != rhs.nextCursor {return false}
    if lhs.hasMore_p != rhs.hasMore_p {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GetSavedChecklistsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSavedChecklistsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_id\0\u{1}topic\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.topic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 1)
    }
    if self.topic != .unspecified {
      try visitor.visitSingularEnumField(value: self.topic, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GetSavedChecklistsRequest, rhs: Rushday_V1_GetSavedChecklistsRequest) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GetSavedChecklistsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSavedChecklistsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}checklists\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.checklists) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.checklists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.checklists, fieldNumber: 2)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GetSavedChecklistsResponse, rhs: Rushday_V1_GetSavedChecklistsResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.checklists != rhs.checklists {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_SaveConversationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SaveConversationRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_id\0\u{3}conversation_id\0\u{1}title\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.title) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 1)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_SaveConversationRequest, rhs: Rushday_V1_SaveConversationRequest) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.title != rhs.title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_SaveConversationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SaveConversationResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}conversation\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._conversation) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._conversation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_SaveConversationResponse, rhs: Rushday_V1_SaveConversationResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._conversation != rhs._conversation {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_UnsaveConversationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnsaveConversationRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_id\0\u{3}conversation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 1)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_UnsaveConversationRequest, rhs: Rushday_V1_UnsaveConversationRequest) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_UnsaveConversationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnsaveConversationResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_UnsaveConversationResponse, rhs: Rushday_V1_UnsaveConversationResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GetSavedConversationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSavedConversationsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GetSavedConversationsRequest, rhs: Rushday_V1_GetSavedConversationsRequest) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GetSavedConversationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSavedConversationsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}conversations\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.conversations) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.conversations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conversations, fieldNumber: 2)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GetSavedConversationsResponse, rhs: Rushday_V1_GetSavedConversationsResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.conversations != rhs.conversations {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_SavedConversation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SavedConversation"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}event_id\0\u{3}conversation_id\0\u{1}title\0\u{1}preview\0\u{3}message_count\0\u{3}created_at\0\u{3}saved_at\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.preview) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.messageCount) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._savedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 2)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 3)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 4)
    }
    if !self.preview.isEmpty {
      try visitor.visitSingularStringField(value: self.preview, fieldNumber: 5)
    }
    if self.messageCount != 0 {
      try visitor.visitSingularInt32Field(value: self.messageCount, fieldNumber: 6)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._savedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_SavedConversation, rhs: Rushday_V1_SavedConversation) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.eventID != rhs.eventID {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.title != rhs.title {return false}
    if lhs.preview != rhs.preview {return false}
    if lhs.messageCount != rhs.messageCount {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._savedAt != rhs._savedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_UpdateChecklistItemRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateChecklistItemRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_id\0\u{3}checklist_id\0\u{3}item_id\0\u{3}is_checked\0\u{1}notes\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.checklistID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.itemID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isChecked) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.notes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 1)
    }
    if !self.checklistID.isEmpty {
      try visitor.visitSingularStringField(value: self.checklistID, fieldNumber: 2)
    }
    if !self.itemID.isEmpty {
      try visitor.visitSingularStringField(value: self.itemID, fieldNumber: 3)
    }
    if self.isChecked != false {
      try visitor.visitSingularBoolField(value: self.isChecked, fieldNumber: 4)
    }
    if !self.notes.isEmpty {
      try visitor.visitSingularStringField(value: self.notes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_UpdateChecklistItemRequest, rhs: Rushday_V1_UpdateChecklistItemRequest) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.checklistID != rhs.checklistID {return false}
    if lhs.itemID != rhs.itemID {return false}
    if lhs.isChecked != rhs.isChecked {return false}
    if lhs.notes != rhs.notes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_UpdateChecklistItemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateChecklistItemResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}updated_item\0\u{3}completed_count\0\u{3}total_count\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updatedItem) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.completedCount) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.totalCount) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._updatedItem {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.completedCount != 0 {
      try visitor.visitSingularInt32Field(value: self.completedCount, fieldNumber: 3)
    }
    if self.totalCount != 0 {
      try visitor.visitSingularInt32Field(value: self.totalCount, fieldNumber: 4)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_UpdateChecklistItemResponse, rhs: Rushday_V1_UpdateChecklistItemResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._updatedItem != rhs._updatedItem {return false}
    if lhs.completedCount != rhs.completedCount {return false}
    if lhs.totalCount != rhs.totalCount {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GetChatHintsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatHintsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_id\0\u{3}conversation_id\0\u{3}last_topic\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.lastTopic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 1)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    if self.lastTopic != .unspecified {
      try visitor.visitSingularEnumField(value: self.lastTopic, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GetChatHintsRequest, rhs: Rushday_V1_GetChatHintsRequest) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.lastTopic != rhs.lastTopic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rushday_V1_GetChatHintsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatHintsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}primary_hint\0\u{3}suggested_hints\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.primaryHint) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.suggestedHints) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.primaryHint.isEmpty {
      try visitor.visitSingularStringField(value: self.primaryHint, fieldNumber: 2)
    }
    if !self.suggestedHints.isEmpty {
      try visitor.visitRepeatedStringField(value: self.suggestedHints, fieldNumber: 3)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rushday_V1_GetChatHintsResponse, rhs: Rushday_V1_GetChatHintsResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.primaryHint != rhs.primaryHint {return false}
    if lhs.suggestedHints != rhs.suggestedHints {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
